---
title: "angel p3607"
author: "angel"
date: "2024-03-11"
output: html_document
---
Project 3- Angel Gallardo
Intro:

Question: Which are the most valued data science skills?

Data - various job listing for data scientist roles scraped from Glassdor
source- https://www.kaggle.com/datasets/andrewmvd/data-scientist-jobs
Goal is to extract the skills from the Job description column
analyze which skills are more valued by sector, and position 
what is the salary range for a data scientist in for each sector





```{r}
df <- read.csv('https://raw.githubusercontent.com/Angelogallardo05/PROJECT3/main/DataScientist.csv')



```



Remove rows with na
```{r}
df <- na.omit(df)


print(df)
```
Load packages
```{r}
library(dplyr)
library(tidyverse)
library(tm)
```


Convert column Job.Description into a corpus. Convert all of the words to lowercase to keep the consistency in text analysis. Remove
all punctuation, numbers, stopwords and white spaces to make make it possible to match with my key_term list.

```{r}

# Convert Job.Description to a corpus
corpus <- Corpus(VectorSource(df$Job.Description))

# Preprocess the text
corpus <- tm_map(corpus, content_transformer(tolower))  # Convert to lowercase
corpus <- tm_map(corpus, removePunctuation)            # Remove punctuation
corpus <- tm_map(corpus, removeNumbers)                # Remove numbers
corpus <- tm_map(corpus, removeWords, stopwords("en")) # Remove English stopwords
corpus <- tm_map(corpus, stripWhitespace)              # Strip whitespace


```


Create a list for the key skill to extract form the Job.Description column. Create a new column called key_skills
```{r}
# Define a function to extract unique key terms from text
extractKeyTerms <- function(text) {
  words <- unlist(strsplit(text, "\\s+"))
  key_terms <- unique(words[tolower(words) %in% c("python", "r", "sql", "machine learning", "deep learning", "data analysis", "analytics", "data analytics", "data management", "statistics", "modelling", "data wrangling", "algorithm", "database management", "data visualization", "visualization", "cloud computing", "predictive modelling", "regression", "machine", "predictive", "quantitative", "building machine learning models", "ai", "artificial intelligence")])
  return(key_terms)
}

# Apply the function to the corpus
key_terms_list <- lapply(corpus, extractKeyTerms)

# Creates a new column in the data frame with key terms
if (length(key_terms_list) > 0) {
  df$Key_Skills <- sapply(key_terms_list, paste, collapse = ", ")
} else {
  df$Key_Skills <- NA
}


print(df)
```





seperate the key words into its own row. merge the expanded data with the original data by the index
```{r}
# Check if 'Key_Skills' column exists
if ("Key_Skills" %in% colnames(df)) {
  # Split the 'Key_Skills' column into individual terms
  split_terms <- strsplit(df$Key_Skills, ", ")
  
  # Check if any split terms are available
  if (any(lengths(split_terms) > 0)) {
    # Create a new data frame to store the results
    expanded_df <- data.frame(Job_ID = rep(df$index, lengths(split_terms)),
                              Key_Term = unlist(split_terms))
    
    # Merge the expanded data frame with the original data frame
    df <- merge(df, expanded_df, by.x = "index", by.y = "Job_ID", all.x = TRUE)
  } else {
    # If no split terms are available, create an empty data frame with the same structure as df
    expanded_df <- data.frame(Job_ID = integer(), Key_Term = character())
    df <- merge(df, expanded_df, by.x = "index", by.y = "Job_ID", all.x = TRUE)
  }
} else {
  print("Key_Skills column does not exist in the dataframe.")
}


print(df)
```



Remove columns that are not needed
```{r}
df <- df[, !(names(df) %in% c("X", "Founded", "Revenue", "Headquarters", "Job.Description","	
Competitors", "Easy,Appply"))]


print(df)
```




Remove non numerc values from the salary.Estimate column 
```{r}
# Remove non-numeric characters except $ and K from Salary.Estimate column
df$Salary.Estimate <- gsub("[^0-9$K-]", "", df$Salary.Estimate)


print(df)
```
Count of key words in order
```{r}
keyword_counts <- df %>%
  drop_na(Key_Term) %>%
  group_by(Key_Term) %>%
  summarise(Count = n()) %>%
  arrange(desc(Count))  # Arrange the results in descending order of counts

# Print the counts
print(keyword_counts)
```


Create a matrix with key words and sectors

```{r}
df$Sector <- factor(df$Sector)

# Create a keyword matrix with counts for each sector
keyword_matrix <- df %>%
  drop_na(Key_Term) %>%
  group_by(Sector, Key_Term) %>%
  summarise(Count = n(), .groups = "drop") %>%
  mutate(Count = as.numeric(Count)) %>%  # Coerce Count to numeric
  pivot_wider(names_from = Sector, values_from = Count, values_fill = 0)

# Calculate the total count for each sector
sector_totals <- colSums(keyword_matrix[, -1])

# Add the total counts as a new row in the keyword_matrix
keyword_matrix_total <- rbind(keyword_matrix, c("Total", sector_totals))

# Convert the counts in the keyword_matrix_total to numeric
keyword_matrix_total[, -1] <- sapply(keyword_matrix_total[, -1], as.numeric)

# Print the updated matrix with totals
print(keyword_matrix_total)
```

create the matrix as a percent to total column
```{r}
normalized_matrix <- keyword_matrix_total

# Loop through each column (excluding the first column which contains the keywords)
for (i in 2:ncol(normalized_matrix)) {
  normalized_matrix[, i] <- round(normalized_matrix[, i] / sector_totals[i - 1]* 100,2)
}

# Print the normalized matrix
print(normalized_matrix)
```


matrix with key words and Job titles

```{r}
# Filter out rows with Sector == "-1"
jobs <- df %>%
  filter(Sector != "-1")

# Calculate the count of occurrences for each job title
job_title_counts <- jobs %>%
  group_by(Job.Title) %>%
  summarise(Count = n()) %>%
  arrange(desc(Count))

# Select the top 10 job titles by count
top_10_job_titles <- job_title_counts %>%
  top_n(10)

# Filter the dataframe to include only rows with the top 10 job titles
jobs <- jobs %>%
  filter(Job.Title %in% top_10_job_titles$Job.Title)

# Remove rows with NA values
jobs <- jobs %>%
  filter(!is.na(Job.Title), !is.na(Key_Term))

# Create a matrix with key words for the top 10 job titles
job_title <- jobs %>%
  group_by(Job.Title, Key_Term) %>%
  summarise(Count = n()) %>%
  pivot_wider(names_from = Job.Title, values_from = Count, values_fill = 0)




# Calculate the total count for each sector
title_total <- colSums(job_title[, -1])

# Add the total counts as a new row in the keyword_matrix
job_totals <- rbind(job_title, c("Total", title_total))

# Convert the counts in the keyword_matrix_total to numeric
job_totals[, -1] <- sapply(job_totals[, -1], as.numeric)

# Print the matrix
print(job_totals)
```





```{r}
job_pct <- job_totals

# Loop through each column (excluding the first column which contains the keywords)
for (i in 2:ncol(job_pct)) {
  job_pct[, i] <- round(job_pct[, i] / title_total[i - 1]* 100,2)
}

# Print the normalized matrix
print(job_pct)
```



graph the salary estimates for the Data scientist position from each sector 
```{r}
library(ggplot2)

# Filter the data to include only job titles that match "Data Scientist"
data_scientist_jobs <- jobs[jobs$Job.Title == "Data Scientist", ]

# Convert the Salary.Estimate column to numeric, calculating the midpoint of each salary range
data_scientist_jobs$Salary_Midpoint <- sapply(strsplit(gsub("\\$|K", "", data_scientist_jobs$Salary.Estimate), "-"), 
                                function(x) mean(as.numeric(x)))

# Create a scatter plot
ggplot(data_scientist_jobs, aes(x = Sector, y = Salary_Midpoint)) +
  geom_point() +
  labs(x = "Sector", y = "Salary Estimate (Midpoint)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```




Conclusion:

This data data provided information about the skills most valued by employers of various sectors. However, I find it surprising that there are some sectors have a very low amount of listings for a any data scientist role; like Mining & Metals and Tourism. 
Furthermore, the skills required by also varied by each position or level of position. The postion title by percentages shows us that the skills required for a Data Scientist positions is proportional compared to the rest. Finally, the salary estimate plot shows us the salary range for a Data scientist position, by sector. Here we see that Business Services has a larger salary range than Accounting & legal, or Finance .








